<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Rice">
<meta name="dcterms.date" content="2024-03-25">

<title>NAO Cost Estimate – Summary – Dan's NAO notebook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Dan’s NAO notebook</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/naobservatory/dans-public-notebook"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">NAO Cost Estimate – Summary</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Rice </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 25, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#the-model" id="toc-the-model" class="nav-link" data-scroll-target="#the-model">The model</a>
  <ul class="collapse">
  <li><a href="#epidemic" id="toc-epidemic" class="nav-link" data-scroll-target="#epidemic">Epidemic</a></li>
  <li><a href="#data-collection" id="toc-data-collection" class="nav-link" data-scroll-target="#data-collection">Data collection</a></li>
  <li><a href="#read-counts" id="toc-read-counts" class="nav-link" data-scroll-target="#read-counts">Read counts</a></li>
  <li><a href="#detection" id="toc-detection" class="nav-link" data-scroll-target="#detection">Detection</a></li>
  <li><a href="#costs" id="toc-costs" class="nav-link" data-scroll-target="#costs">Costs</a></li>
  </ul></li>
  <li><a href="#key-results" id="toc-key-results" class="nav-link" data-scroll-target="#key-results">Key results</a>
  <ul class="collapse">
  <li><a href="#sequencing-effort-required-in-a-deterministic-model" id="toc-sequencing-effort-required-in-a-deterministic-model" class="nav-link" data-scroll-target="#sequencing-effort-required-in-a-deterministic-model">Sequencing effort required in a deterministic model</a></li>
  <li><a href="#optimal-sampling-interval" id="toc-optimal-sampling-interval" class="nav-link" data-scroll-target="#optimal-sampling-interval">Optimal sampling interval</a></li>
  <li><a href="#additional-sequencing-required-to-ensure-a-high-probability-of-detection" id="toc-additional-sequencing-required-to-ensure-a-high-probability-of-detection" class="nav-link" data-scroll-target="#additional-sequencing-required-to-ensure-a-high-probability-of-detection">Additional sequencing required to ensure a high probability of detection</a></li>
  <li><a href="#small-pool-noise" id="toc-small-pool-noise" class="nav-link" data-scroll-target="#small-pool-noise">Small pool noise</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a>
  <ul class="collapse">
  <li><a href="#potential-extensions" id="toc-potential-extensions" class="nav-link" data-scroll-target="#potential-extensions">Potential extensions</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="background" class="level1">
<h1>Background</h1>
<p>The goal of this project was to build a model that allows us to:</p>
<ul>
<li>Estimate the cost of sampling and sequencing required to run an effective NAO.</li>
<li>Calculate the sequencing depth necessary to detect a virus by the time it reaches a target cumulative incidence.</li>
<li>Understand which parameters are most important to understand and/or optimize to determine the viability of an NAO.</li>
</ul>
<p>We had previously done a very simple version of this for the P2RA project. Here, we wanted to formalize the approach and include more details.</p>
<p>Previous documents:</p>
<ol type="1">
<li><a href="https://docs.google.com/document/d/1_DwBbE3l08ccbDiX0kxZwWqwiNm2CauHTQeDvlEaFRI">NAO Cost Estimate Outline</a></li>
<li><a href="https://docs.google.com/document/d/1aHboNUDrXWAmTmZGg9Ne8dyTUdEpsluafB48DJp1UN4">Simple detection cost for P2RA</a></li>
<li><a href="https://docs.google.com/document/d/1YAy4Dnvk7H5J7jOt7iCeBYqE6z3TdgHSr3jetimlJHo">NAO Cost Estimate MVP outline and assumptions</a></li>
<li><a href="../../posts/2024-02-02_CostEstimateMVP/index.html">NAO Cost Estimate MVP</a></li>
<li><a href="../../posts/2024-02-08_OptimalSamplingInterval/index.html">NAO Cost Estimate – Optimizing the sampling interval</a></li>
<li><a href="../../posts/2024-02-22_StochasticMVP/index.html">NAO Cost Estimate – Adding noise</a></li>
</ol>
</section>
<section id="the-model" class="level1">
<h1>The model</h1>
<p>Using the framework developed in <a href="https://docs.google.com/document/d/1_DwBbE3l08ccbDiX0kxZwWqwiNm2CauHTQeDvlEaFRI">NAO Cost Estimate Outline</a>, our model has the following components. Unless otherwise noted, see <a href="../../posts/2024-02-02_CostEstimateMVP/index.html">NAO Cost Estimate MVP</a> for details.</p>
<section id="epidemic" class="level2">
<h2 class="anchored" data-anchor-id="epidemic">Epidemic</h2>
<p>The prevalence of the virus grows exponentially and deterministically in a single population. The fraction of people currently infectious and shedding is equal and given by: <span class="math display">\[
p(t) = \frac{1}{N} e^{r t},
\]</span> where <span class="math inline">\(N\)</span> is the population size and <span class="math inline">\(r\)</span> is the growth rate.</p>
<p>The cumulative incidence (as a fraction of the population) in this model is: <span class="math display">\[
c(t) \approx \frac{r + \beta}{r} p(t),
\]</span> where <span class="math inline">\(\beta\)</span> is the rate at which infected people recover. Note that both prevalence and cumulative incidence grow exponentially, which is convenient for many of our calculations.</p>
</section>
<section id="data-collection" class="level2">
<h2 class="anchored" data-anchor-id="data-collection">Data collection</h2>
<p>We collect samples from a single sampling site at regular intervals, spaced <span class="math inline">\(\delta t\)</span> apart. The material for the sample is collected uniformly over a window of length <span class="math inline">\(w\)</span>. (When <span class="math inline">\(w \to 0\)</span>, we have a single grab sample per collection, when <span class="math inline">\(w \to \delta t\)</span> we have continuous sampling.) Each sample is sequenced to a total depth of <span class="math inline">\(n\)</span> reads.</p>
<p>We also consider the a delay of <span class="math inline">\(t_d\)</span> between the collection of the sample and the data processing. This delay accounts for sample transport, sample prep, sequencing, and data analysis.</p>
</section>
<section id="read-counts" class="level2">
<h2 class="anchored" data-anchor-id="read-counts">Read counts</h2>
<p>We considered three different models of the number of reads in each sample from the epidemic virus:</p>
<ol type="1">
<li>A deterministic model where the number of reads in a sample at time t is <span class="math display">\[
k = \mu = n b \int_{t-w}^{t} p(t) \frac{dt}{w},
\]</span> where <span class="math inline">\(b\)</span> is the P2RA factor that converts between prevalence and relative abundance.</li>
<li>A stochastic model that accounts for Poisson counting noise and variation in the latent relative abundance. In this model, the number of reads is a random variable drawn from a Poisson-gamma mixture with mean <span class="math inline">\(\mu\)</span> (as in 1.) and inverse overdispersion parameter <span class="math inline">\(\phi\)</span>. Large <span class="math inline">\(\phi\)</span> means that the relative abundance is well-predicted by our deterministic model, whereas small <span class="math inline">\(\phi\)</span> means that there is a lot of excess variation beyond what comes automatically from having a finite read depth.</li>
<li>A stochastic model where we sequence a pooled sample of <span class="math inline">\(n_p\)</span> individuals. This allows us to consider the effect of sampling a small number of, e.g., nasal swabs rather than wastewater.</li>
</ol>
<p>See <a href="../../posts/2024-02-22_StochasticMVP/index.html">NAO Cost Estimate – Adding noise</a> for stochastic models.</p>
</section>
<section id="detection" class="level2">
<h2 class="anchored" data-anchor-id="detection">Detection</h2>
<p>We model detection based on the cumulative number of viral reads over all samples. When this number reaches a threshold value <span class="math inline">\(\hat{K}\)</span>, the virus is detected.</p>
</section>
<section id="costs" class="level2">
<h2 class="anchored" data-anchor-id="costs">Costs</h2>
<p>We considered two components of cost:</p>
<ol type="1">
<li>The per-read cost of sequencing <span class="math inline">\(d_r\)</span></li>
<li>The per-sample cost of collection and processing <span class="math inline">\(d_s\)</span></li>
</ol>
<p>See <a href="../../posts/2024-02-08_OptimalSamplingInterval/index.html">NAO Cost Estimate – Optimizing the sampling interval</a> for details.</p>
</section>
</section>
<section id="key-results" class="level1">
<h1>Key results</h1>
<section id="sequencing-effort-required-in-a-deterministic-model" class="level2">
<h2 class="anchored" data-anchor-id="sequencing-effort-required-in-a-deterministic-model">Sequencing effort required in a deterministic model</h2>
<p>In <a href="../../posts/2024-02-02_CostEstimateMVP/index.html">NAO Cost Estimate MVP</a>, we found the sampled depth per unit time required to detect a virus by the time it reaches cumulative incidence <span class="math inline">\(\hat{c}\)</span> to be: <span class="math display">\[
\frac{n}{\delta t} = (r + \beta) \left(\frac{\hat{K}}{b \hat{c}} \right)
    \left(\frac
        {e^{-r\delta t} {\left(e^{r \delta t} - 1\right)}^2}
        {{\left(r \delta t\right)}^2}
        \right)
    e^{r t_d}.
\]</span> This result is for grab sampling, which in our model is a good approximation for windowed-composite sampling when <span class="math inline">\(r w \ll 1\)</span>.</p>
<p>The first two terms on the right-hand side are equivalent to the result from the <a href="https://docs.google.com/document/d/1aHboNUDrXWAmTmZGg9Ne8dyTUdEpsluafB48DJp1UN4">P2RA model</a> using the conversion between prevalence and incidence implied by our exponential growth model.</p>
<p>The third term in parentheses is an adustment factor for collecting samples at <span class="math inline">\(\delta t\)</span> intervals. It includes two factors:</p>
<ol type="1">
<li>the delay between when the virus is theoretically detectable and the next sample taken, and</li>
<li>the benefit of taking a grab sample late in the sampling interval when the prevalence is higher.</li>
</ol>
<p>This term has Taylor expansion <span class="math inline">\(1 + \frac{{(r \delta t)}^2}{12} + \mathcal{O}{(r\delta t)}^3\)</span>.</p>
<p>The final term is the cost of the <span class="math inline">\(t_d\)</span> delay between sampling and data processing.</p>
</section>
<section id="optimal-sampling-interval" class="level2">
<h2 class="anchored" data-anchor-id="optimal-sampling-interval">Optimal sampling interval</h2>
<p>In <a href="../../posts/2024-02-08_OptimalSamplingInterval/index.html">NAO Cost Estimate – Optimizing the sampling interval</a>, we found the sampling interval <span class="math inline">\(\delta t\)</span> that minimized the total cost. Longer <span class="math inline">\(\delta t\)</span> between samples saves money on sample processing, but requires more depth to make up for the delay of waiting for the next sample after the virus becomes detectable. We found that the optimal <span class="math inline">\(\delta t\)</span> satisfies (again for grab sampling):</p>
<p><span class="math display">\[
r \delta t \approx {\left(
    6 \frac{d_s}{d_r} \frac{b \hat{c}}{\hat{k}}
    \left( \frac{r}{r + \beta} \right)
    e^{- r t_d}
    \right)}^{1/3}.
\]</span></p>
<p>When sampling optimally, the per-sample sequencing cost (<span class="math inline">\(n d_r\)</span>) should be a multiple of the sample costs(<span class="math inline">\(d_s\)</span>): <span class="math display">\[
n d_r \approx \frac{6}{{\left(r \delta t\right)}^2} d_s
\]</span></p>
</section>
<section id="additional-sequencing-required-to-ensure-a-high-probability-of-detection" class="level2">
<h2 class="anchored" data-anchor-id="additional-sequencing-required-to-ensure-a-high-probability-of-detection">Additional sequencing required to ensure a high probability of detection</h2>
<p>In <a href="../../posts/2024-02-22_StochasticMVP/index.html">NAO Cost Estimate – Adding noise</a>, we change our detection criterion from requiring the expected number of reads to reach the threshold <span class="math inline">\(\hat{K}\)</span> to requiring that the number of reads reach <span class="math inline">\(\hat{K}\)</span> with high probability, <span class="math inline">\(p\)</span>. We ask how much higher the cumulative incidence has to be to meet the second criterion than the first.</p>
<p>We find that a key parameter is <span class="math inline">\(\nu = \frac{\phi}{r \delta t}\)</span>, which measures the departure of the read count distribution from Poisson. When <span class="math inline">\(\mu / \nu \ll 1\)</span>, the Poisson noise dominates and our detection criterion is: <span class="math display">\[
\hat{K} \approx \mu + \mu^{1/2} \Phi^{-1}(1 - p)
\]</span> where <span class="math inline">\(\Phi^{-1}\)</span> is the inverse CDF of a standard Gaussian distribution. Solving this equation for <span class="math inline">\(\mu\)</span> gives the corresponding number of copies in the deterministic model required to detect with probability <span class="math inline">\(p\)</span>.</p>
<p>When <span class="math inline">\(\mu / \nu \gg 1\)</span>, the Poisson noise is small compared to the variation in the latent relative abundance. Here the detection criterion is: <span class="math display">\[
\hat{K} \approx \mu \left(1 + \frac{1}{{(2\nu)}^{1/2}} w_p(\nu) \right)
\]</span> where <span class="math inline">\(w_{1-p}(\nu) &lt; 0\)</span> is a function that measures the departure of the distribution from Gaussian at quantile <span class="math inline">\(1-p\)</span>. The term in parentheses is thus less than one and measures the ratio of the detection threshold to the deterministic approximation at detection.</p>
<p>Numerical exploration of these regimes suggests that we expect to need 1.5–3 times more sequencing than the deterministic model predicts to detect with 95% probability by the target cumulative incidence.</p>
</section>
<section id="small-pool-noise" class="level2">
<h2 class="anchored" data-anchor-id="small-pool-noise">Small pool noise</h2>
<p>In the <a href="../../posts/2024-02-22_StochasticMVP/index.html#appendix-small-pool-noise">Appendix</a> to the noise post, we showed that the effect of pooling a small number of samples is controlled by <span class="math inline">\(a\)</span>, the average number of viral reads each infected person contributes to the sample. With fixed sampling depth, <span class="math inline">\(a\)</span> is inversely proportional to the pool size <span class="math inline">\(n_p\)</span>. We found that if the detection threshold is one read <span class="math inline">\(\hat{K} = 1\)</span>, sequencing depth required to ensure a given probability of detection increases in proportion to <span class="math display">\[
\frac{a}{1 - e^{-a}}.
\]</span> We expect a similar result to hold for higher detection thresholds.</p>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<ul>
<li>Nothing in our analysis here changes the intuition that the P2RA factor (here <span class="math inline">\(b\)</span>) is very important for cost, especially because it appears to vary over several orders of magnitude for different viruses and studies.</li>
<li>The sampling interval is not expected to be very important for cost, assuming <span class="math inline">\(r \delta t &lt; 1\)</span>. The cost of delay from longer interval is partially offset by the benefit of sampling later when the prevalence is higher.</li>
<li>In constrast, the delay between sample collection and data analysis could matter a lot because it does not have a corresponding benefit. The required depth grows exponentially with <span class="math inline">\(r t_d\)</span>.</li>
<li>We have sometimes considered the benefit to noise in the read count distribution. Noisier distributions sometimes let us detect something while it is still too rare to detect on average. However, our analysis here shows that if our goal is to detect by the target cumulative incidence with high probability, noise is unambiguously bad and could increase our required depth several times over.</li>
<li>We currently do not have any estimate of <span class="math inline">\(\phi\)</span>, the inverse overdispersion of read counts relative to Poisson. We should try to measure it empirically in our sequence data.</li>
</ul>
<section id="potential-extensions" class="level2">
<h2 class="anchored" data-anchor-id="potential-extensions">Potential extensions</h2>
<ul>
<li>We could turn this analysis into a “plausibility map”: Given a system design (budget or <span class="math inline">\(n\)</span>, <span class="math inline">\(\delta t\)</span>, <span class="math inline">\(t_d\)</span>, etc.), what ranges of growth rates and P2RA factors could we detect reliably by a target cumulative incidence?</li>
<li>We could extend the model to consider multiple sampling sites.</li>
<li>The current epidemic model is completely deterministic. It would be good to check whether adding randomness changes our conclusions. (I suspect it won’t in a single-population model, but may matter for multiple sampling sites.)</li>
<li>We could consider a more sophisticated detection model than just cumulative reads. For example we could analyze a toy model of EGD.</li>
<li>We could explore the noise distribution of real data and try to measure <span class="math inline">\(\phi\)</span> and whether the latent noise is mostly independent or correlated between samples.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>