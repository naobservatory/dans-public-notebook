<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Rice">
<meta name="dcterms.date" content="2024-02-02">

<title>NAO Cost Estimate MVP – Dan’s NAO notebook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Dan’s NAO notebook</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/naobservatory/dans-public-notebook"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">NAO Cost Estimate MVP</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dan Rice </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 2, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#epidemic-model" id="toc-epidemic-model" class="nav-link" data-scroll-target="#epidemic-model">Epidemic model</a>
  <ul class="collapse">
  <li><a href="#prevalence-and-incidence" id="toc-prevalence-and-incidence" class="nav-link" data-scroll-target="#prevalence-and-incidence">Prevalence and incidence</a></li>
  <li><a href="#cumulative-incidence" id="toc-cumulative-incidence" class="nav-link" data-scroll-target="#cumulative-incidence">Cumulative incidence</a></li>
  <li><a href="#domain-of-validity" id="toc-domain-of-validity" class="nav-link" data-scroll-target="#domain-of-validity">Domain of validity</a></li>
  </ul></li>
  <li><a href="#sampling-sequencing-and-detection" id="toc-sampling-sequencing-and-detection" class="nav-link" data-scroll-target="#sampling-sequencing-and-detection">Sampling, sequencing, and detection</a>
  <ul class="collapse">
  <li><a href="#sampling-to-relative-abundance" id="toc-sampling-to-relative-abundance" class="nav-link" data-scroll-target="#sampling-to-relative-abundance">Sampling to relative abundance</a></li>
  <li><a href="#continuous-sampling" id="toc-continuous-sampling" class="nav-link" data-scroll-target="#continuous-sampling">Continuous sampling</a></li>
  <li><a href="#grab-sampling" id="toc-grab-sampling" class="nav-link" data-scroll-target="#grab-sampling">Grab sampling</a></li>
  </ul></li>
  <li><a href="#numerical-example" id="toc-numerical-example" class="nav-link" data-scroll-target="#numerical-example">Numerical example</a></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next steps</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>See <a href="https://docs.google.com/document/d/1YAy4Dnvk7H5J7jOt7iCeBYqE6z3TdgHSr3jetimlJHo/edit">Google Doc</a> for background. See also <a href="https://docs.google.com/document/d/1aHboNUDrXWAmTmZGg9Ne8dyTUdEpsluafB48DJp1UN4/edit#heading=h.vijzo0j6vjkg">Simple detection cost model</a> for P2RA version.</p>
</section>
<section id="epidemic-model" class="level2">
<h2 class="anchored" data-anchor-id="epidemic-model">Epidemic model</h2>
<section id="prevalence-and-incidence" class="level3">
<h3 class="anchored" data-anchor-id="prevalence-and-incidence">Prevalence and incidence</h3>
<p>Consider a population of <span class="math inline">\(N\)</span> individuals. We focus on the phase of the epidemic when it is growing exponentially. This will be approximately true at an intermediate time when the virus is common enough that we can neglect noise in reproduction, but rare enough that it is not running out of susceptible people to infect. Let the rate of new infections per infected persion per unit time be <span class="math inline">\(N \alpha\)</span> and the rate of recovery of an infected person to be <span class="math inline">\(\beta\)</span>. Then, we have the following ODE for the prevalence (the number of infected people, not the proportion of the population as in the P2RA report) <span class="math inline">\(P(t)\)</span>:</p>
<p><span class="math display">\[
\frac{dP}{dt} \approx \alpha N P - \beta P.
\]</span></p>
<p>The first term on the right-hand side is the incidence per unit time: <span class="math inline">\(I \approx \alpha N P\)</span>. (Note that we are assuming that the number of susceptible people is approximately <span class="math inline">\(N\)</span>, which will cease to be true as the virus becomes common.)</p>
<p>Solving this equation and choosing <span class="math inline">\(t = 0\)</span> to be the time when one person is infected gives: <span class="math display">\[
\begin{align}
P(t) &amp; = e^{(\alpha N - \beta) t} \\
     &amp; = e^{rt} \\
I(t) &amp; = \alpha N e^{rt} \\
     &amp; = (r + \beta) e^{rt},
\end{align}
\]</span> where we have defined the exponential growth rate <span class="math inline">\(r \equiv \alpha N - \beta\)</span>.</p>
</section>
<section id="cumulative-incidence" class="level3">
<h3 class="anchored" data-anchor-id="cumulative-incidence">Cumulative incidence</h3>
<p>As a yardstick for measuring the progress of the epidemic, we are interested in the <em>cumulative</em> incidence, <span class="math inline">\(C(t)\)</span>, the number of people who have ever been infected. Integrating <span class="math inline">\(I(t)\)</span> with the initial condition <span class="math inline">\(C(0) = 1\)</span> to account for the single individual infected at <span class="math inline">\(t = 0\)</span>, we have: <span class="math display">\[
\begin{align}
C(t) &amp; = 1 + \int_0^t I(t') dt' \\
     &amp; = 1 + \frac{r + \beta}{r} (e^{rt} - 1).
\end{align}
\]</span> Note that when sick individuals never recover (<span class="math inline">\(\beta = 0\)</span>), <span class="math inline">\(C(t) = P(t)\)</span>, as expected.</p>
<p>A useful feature of the exponential growth regime is that all of our quantities of interest grow exponentially at the same rate and are thus in proportion to one another: <span class="math display">\[
\begin{align}
I(t) &amp; = (r + \beta) P(t) \\
C(t) &amp; \sim \frac{r + \beta}{r} P(t), \text{as } t \to \infty.
\end{align}
\]</span></p>
<p>Rearranging, we see that the fraction of cumulative incidence that are currently infected is controled by the ratio of growth rate to recovery rate: <span class="math display">\[
\frac{P(t)}{C(t)} \sim \frac{r}{r + \beta}.
\]</span> This ranges from zero when the epidemic grows slowly and individuals recover quickly, to one wher the epidemic grows much faster than recovery. For a virus like SARS-CoV-2, where both doubling and recovery times were on the order of a week, we expect on the order of half of the cumulative infections to be currently sick during the exponetial phase.</p>
</section>
<section id="domain-of-validity" class="level3">
<h3 class="anchored" data-anchor-id="domain-of-validity">Domain of validity</h3>
<p>As described above, the approximation of deterministic exponential growth is valid when the number of infected individuals is large enough that the growth is roughly deterministic but small enough that most of the population is still susceptible. Here we’ll approximate those bounds.</p>
<section id="deterministic-growth" class="level4">
<h4 class="anchored" data-anchor-id="deterministic-growth">Deterministic growth</h4>
<p>A simple stochastic model of the start of an epidemic is that infections and recoveries in a small increment of time <span class="math inline">\(dt\)</span> are independent of one another, that is: <span class="math display">\[
\begin{align}
\text{\# Births} &amp; \sim \text{Poisson}(\alpha N P dt) \\
\text{\# Deaths} &amp; \sim \text{Poisson}(\beta P dt).
\end{align}
\]</span> This implies that the change in prevalence, <span class="math inline">\(dP = (\text{\# Births}) - (\text{\# Deaths})\)</span>, during <span class="math inline">\([t, t+dt)\)</span> has mean and variance: <span class="math display">\[
\begin{align}
\mathbb{E}(dP) &amp; = (\alpha N - \beta) P dt \\
               &amp; = r P dt \\
\mathbb{V}(dP) &amp; = (\alpha N + \beta) P dt \\
               &amp; = (r + 2 \beta) P dt.
\end{align}
\]</span></p>
<p>A deterministic approximation is good when the coefficient of variation of <span class="math inline">\(dP\)</span> is much smaller than one, that is: <span class="math display">\[
\begin{align}
\frac{\sqrt{\mathbb{V}(dP)}}{\mathbb{E}(dP)} &amp; \ll 1 \\
\frac{\sqrt{(r + 2 \beta) P dt}}{r P dt} &amp; \ll 1 \\.
\end{align}
\]</span> Some algebra gives the condition that the prevalence is larger than a critical value: <span class="math display">\[
P \gg \frac{r + 2 \beta}{r^2 dt}.
\]</span> It remains to choose a suitable increment of time. We expect the prevalence to change significantly (<span class="math inline">\(\mathbb{E}(\frac{dP}{P}) = 1\)</span>) on the timescale <span class="math inline">\(r^{-1}\)</span> so <span class="math inline">\(dt = r^{-1}\)</span> is a reasonable choice as long as <span class="math inline">\(r \gtrsim \beta\)</span>. This gives the condition <span class="math display">\[
P \gg \frac{r + 2 \beta}{r} = 1 + 2 \beta / r.
\]</span> When this condition is met, we expect the epidemic to grow approximately deterministically at rate <span class="math inline">\(r\)</span>.</p>
<p>Note that this condition is violated at <span class="math inline">\(t = 0\)</span>. We must thus reinterpret <span class="math inline">\(t = 0\)</span> as the <em>effective</em> time that the epidemic would have infected a single person if our deterministic approximation for <span class="math inline">\(P \gg 1 + 2\beta/r\)</span> were extended backwards in time. [TODO: estimate the error in cumulative infections introduced by making this approximation.]</p>
</section>
<section id="exponential-growth" class="level4">
<h4 class="anchored" data-anchor-id="exponential-growth">Exponential growth</h4>
<p>As the virus spreads, the number of susceptible people declines, reducing the rate of spread and resulting in sub-exponential growth. Let the number of susceptible people be <span class="math inline">\(S(t)\)</span>, then the incidence per time is: <span class="math display">\[
I(t) = \alpha S(t) P(t).
\]</span> Above, we assumed that <span class="math inline">\(S(t) = N\)</span>. <span class="math inline">\(I(t)\)</span> will thus be reduced by half by the time <span class="math inline">\(S(t) = N / 2\)</span>. This is a convenient upper bound on the domain of validity.</p>
<p>Assuming that anyone previously infected is no longer susceptible, we have: <span class="math display">\[
\begin{align}
S(t) &amp; \gg N / 2 \\
N - C(t) &amp; \gg N / 2 \\
C(t) &amp; \ll N / 2.
\end{align}
\]</span></p>
<p>Using <span class="math inline">\(C = \frac{r + \beta}{r} P\)</span> in the exponential regime, we can put this together with our lower bound of the deterministic approximation to get the region of validity: <span class="math display">\[
1 + 2\beta / r \ll P \ll \frac{N}{2 (1 + \beta / r)}.
\]</span> This shows that as long as the population is large (<span class="math inline">\(N \gg 1\)</span>), and the growth rate is not too slow compared to the recovery rate (<span class="math inline">\(r \gtrsim \beta\)</span>), there will be a wide range of <span class="math inline">\(P\)</span> for which growth is approximately deterministic and exponential.</p>
</section>
</section>
</section>
<section id="sampling-sequencing-and-detection" class="level2">
<h2 class="anchored" data-anchor-id="sampling-sequencing-and-detection">Sampling, sequencing, and detection</h2>
<p>Consider a set of samples taken at times <span class="math inline">\(\{t_0, t_1, \ldots\}\)</span>, where <span class="math inline">\(t_0 \ge 0\)</span> is the the first sampling time after the virus begins to spread. (Presumably sampling has been ongoing but we’ll ignore the earlier samples.) We sequence sample <span class="math inline">\(i\)</span> to a total depth of <span class="math inline">\(n_i\)</span> reads and find that <span class="math inline">\(k_i\)</span> match the sequence of the pandemic virus.</p>
<p>We consider the virus to be detected when the cumulative number of viral reads reaches a threshold <span class="math inline">\(\hat{K}\)</span>. We’ll define <span class="math inline">\(\hat{t}\)</span> to be the smallest sample time <span class="math inline">\(t_i\)</span> such that: <span class="math display">\[
K_i \equiv \sum_{j=0}^i k_j \geq \hat{K}.
\]</span> We also want to consider the effect of the delay, <span class="math inline">\(t_d\)</span>, between when the critical sample is collected and when we have processed, sequenced, and analyzed the data.</p>
<p>We will assess the success of a method by the (population-scaled) cumulative incidence at the time of detection, accounting for the delay: <span class="math display">\[
c(\hat{t} + t_d) \equiv C(\hat{t} + t_d) / N
\]</span></p>
<p>We’re interested in taking samples from a large population (<span class="math inline">\(N \gg 1\)</span>). In such a population, our ability to detect will depend not on the the raw number of people infected <span class="math inline">\(P\)</span>, but on the proportion <span class="math inline">\(p \equiv P / N\)</span>. At detection, <span class="math inline">\(p\)</span> will be at some typical magnitude that depends on our sensitivity but does not depend on <span class="math inline">\(N\)</span>. We can simplify our equations by neglecting terms that are <span class="math inline">\(\mathcal{O}(N^{-1})\)</span> while keeping terms of order <span class="math inline">\(p = e^{r t} / N\)</span>. This is valid because we’ve already assumed that <span class="math inline">\(e^{r t} \gg 1\)</span> so the latter are always larger than the former.</p>
<p>Using the equations above for cumulative incidence, we have the following simplification: <span class="math display">\[
\begin{align}
c(t) &amp; = \frac{1 + \frac{r + \beta}{r}\left(e^{rt} - 1\right)}{N} \\
     &amp; = \frac{r + \beta}{r} \frac{e^{rt}}{N} + \mathcal{O}(N^{-1}).
\end{align}
\]</span></p>
<p>Note that we can immediately see the cost of delay: <span class="math display">\[
c(\hat{t} + t_d) = \frac{r + \beta}{r} \frac{e^{r\hat{t}}}{N} e^{r t_d}.
\]</span> With an exponentially growing pandemic, post-sampling delay multiplies our cumulative incidence at detection by <span class="math inline">\(e^{rt_d}\)</span>.</p>
<p>In the rest of this section, we answer the question:</p>
<blockquote class="blockquote">
<p>If we want to detect the virus by the time it reaches a particular cumulative incidence, <span class="math inline">\(\hat{c}\)</span>, how much sequencing do we need to do per unit time?</p>
</blockquote>
<section id="sampling-to-relative-abundance" class="level3">
<h3 class="anchored" data-anchor-id="sampling-to-relative-abundance">Sampling to relative abundance</h3>
<p>Here we make two more important deterministic assumptions:</p>
<ol type="1">
<li>The viral read counts are deterministic, given the expected relative abundance, <span class="math inline">\(a_i\)</span>, in each sample: <span class="math inline">\(k_i = n_i a_i\)</span>.</li>
<li>The expected relative abundance is itself a deterministic functional of the prevalence: <span class="math display">\[
a_i = b \int \frac{P(t)}{N} \rho_i(t) dt.
\]</span> Here, <span class="math inline">\(\rho_i\)</span> is a density that says how much of sample <span class="math inline">\(i\)</span> was collected at different times, and <span class="math inline">\(b\)</span> is a fixed conversion factor between prevalence and relative abundance. (Note <span class="math inline">\(b = RA_p(1)\)</span> in the P2RA manuscript.)</li>
</ol>
<p>From here on, it will simplify things to specify two concrete sampling schemes. Both schemes collect evenly-spaced samples with the same depth:</p>
<ul>
<li><span class="math inline">\(n_i = n\)</span></li>
<li><span class="math inline">\(t_i - t_{i-1} = \delta t\)</span></li>
<li><span class="math inline">\(0 \leq t_0 &lt; \delta t\)</span>, since we don’t know how long before the first sample the pandemic began.</li>
</ul>
<p>Our two schemes differ in when the material for the samples is collected. They are:</p>
<ol type="1">
<li>Continuous sampling: <span class="math inline">\(\rho_i(t) = \frac{1}{\delta t}\)</span> for <span class="math inline">\(t \in [t_{i-1}, t_i)\)</span>.</li>
<li>Grab sampling: <span class="math inline">\(\rho_i(t) = \delta(t - t_i)\)</span>, i.e., the whole sample is collected at <span class="math inline">\(t_i\)</span>. (Here, <span class="math inline">\(\delta(t)\)</span> is the Dirac delta function.)</li>
</ol>
<p>In the <a href="../../posts/2024-02-08_OptimalSamplingInterval/index.html#windowed-composite-sampling">next notebook</a>, we consider a third, intermediate scheme: windowed composite sampling. In this scheme, material is collected continuously for a fixed window, usually 24 hours. (In practice, it is not sampled continuously but at regular intervals over the window.) Derivation of this case is a straightforward extension of the cases considered here, using <span class="math inline">\(\rho_i(t) = w^{-1}\)</span> for <span class="math inline">\(t \in [t_i - w, t_i)\)</span> with window length <span class="math inline">\(w\)</span>. For short windows (<span class="math inline">\(w \to 0\)</span>), this case approaches grab sampling. For <span class="math inline">\(w \to \delta t\)</span> it approaches composite sampling.</p>
</section>
<section id="continuous-sampling" class="level3">
<h3 class="anchored" data-anchor-id="continuous-sampling">Continuous sampling</h3>
<p>First, we use the assumptions in the previous section to calculate the cumulative reads by sample <span class="math inline">\(i\)</span>: <span class="math display">\[
\begin{align}
K_i &amp; = \sum_{j=0}^{i} n a_i \\
    &amp; = n \sum_{j=0}^{i} b \int_{t_{j-1}}^{t_j} \frac{P(t)}{N} \frac{dt}{\delta t} \\
    &amp; = \frac{n b}{\delta t} \int_{0}^{t_i} \frac{P(t)}{N} dt.
\end{align}
\]</span></p>
<p>At this point, we could make the substitution <span class="math inline">\(I(t) = (r + \beta) P(t)\)</span> from our exponential model. This would give us: <span class="math display">\[
\begin{align}
K_i &amp; = \frac{nb}{\delta t} (r + \beta) \int_{0}^{t_i} \frac{I(t)}{N} dt \\
    &amp; = \frac{n b (r + \beta)}{\delta t} c(t_i),
\end{align}
\]</span> which is the result from the simple calculation in the P2RA manuscript, using the conversion factor <span class="math inline">\(r + \beta\)</span> to convert between <span class="math inline">\(RA_p\)</span> and <span class="math inline">\(RA_i\)</span>, which is only valid in the exponential growth case.</p>
<p>Instead, we’ll proceed in a more general way, which will extend to the grab sampling model and account for the discrete nature of our sampling.</p>
<p>Using our exponential growth model for <span class="math inline">\(P\)</span>, we have: <span class="math display">\[
\begin{align}
K_i &amp; = \frac{nb}{\delta t}
\end{align}
\]</span></p>
<p>One somewhat subtle complication comes from the fact that we don’t know how the start of the epidemic lines up with our sampling schedule. For example, if we sample weekly, the detection time will depend on which day of the week exponential growth effectively starts (<span class="math inline">\(t=0\)</span> in the model). When delay between the start of the epidemic and the first sample (<span class="math inline">\(t_0\)</span>) is larger, we may eventually detect the virus one sample earlier than when the delay is smaller. In the figure below, the three colored series show <span class="math inline">\(K_i\)</span> for three series of samples that differ only by the relative timing of their sample collection (e.g., all samples are collected weekly, but one series collects on Mondays, another on Tuesdays, etc.) Note that the red figure, whose first sample was taken latest relative to the start of the pandemic, crosses the threshold (solid black line) one sample earlier than the others.</p>
<div id="38746a32" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="38746a32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="38746a32-1"><a href="#38746a32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="38746a32-2"><a href="#38746a32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="38746a32-3"><a href="#38746a32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="38746a32-4"><a href="#38746a32-4" aria-hidden="true" tabindex="-1"></a>t_max <span class="op">=</span> <span class="dv">8</span></span>
<span id="38746a32-5"><a href="#38746a32-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="38746a32-6"><a href="#38746a32-6" aria-hidden="true" tabindex="-1"></a>k_hat <span class="op">=</span> <span class="dv">100</span></span>
<span id="38746a32-7"><a href="#38746a32-7" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="38746a32-8"><a href="#38746a32-8" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, t_max, <span class="fl">0.1</span>)</span>
<span id="38746a32-9"><a href="#38746a32-9" aria-hidden="true" tabindex="-1"></a>plt.plot(time, np.exp(r <span class="op">*</span> time), <span class="st">"k:"</span>)</span>
<span id="38746a32-10"><a href="#38746a32-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t_0 <span class="kw">in</span> [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>]:</span>
<span id="38746a32-11"><a href="#38746a32-11" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.arange(t_0, t_max, dt)</span>
<span id="38746a32-12"><a href="#38746a32-12" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> np.exp(r <span class="op">*</span> t)</span>
<span id="38746a32-13"><a href="#38746a32-13" aria-hidden="true" tabindex="-1"></a>    plt.plot(t, k, <span class="st">"o"</span>, label<span class="op">=</span>t_0)</span>
<span id="38746a32-14"><a href="#38746a32-14" aria-hidden="true" tabindex="-1"></a>plt.hlines(k_hat, <span class="dv">0</span>, t_max, <span class="st">"k"</span>)</span>
<span id="38746a32-15"><a href="#38746a32-15" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">"log"</span>)</span>
<span id="38746a32-16"><a href="#38746a32-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cumulative reads $K$"</span>)</span>
<span id="38746a32-17"><a href="#38746a32-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="38746a32-18"><a href="#38746a32-18" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Effect of sample timing"</span>)</span>
<span id="38746a32-19"><a href="#38746a32-19" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">"$t_0$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-2-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We account for this effect by splitting <span class="math inline">\(\hat{t}\)</span> into two components:</p>
<ol type="1">
<li>The earliest time possible to detect, <span class="math inline">\(t^{\star}\)</span>, found by allowing <span class="math inline">\(K\)</span> to vary continously in time (dotted line above)</li>
<li>The residual time waiting for the next sample to be collected. This waiting time depends on the arbitrary start time of the epidemic within our sampling cycle so we have reason to expect it to take any particular value. Thus, we average it over a uniform distribution.</li>
</ol>
<p>First, we will find an implicit equation for <span class="math inline">\(t^{\star}\)</span>: <span class="math display">\[
\begin{align}
\hat{K} &amp; = \frac{nb}{\delta t} \int_0^{t^{\star}} \frac{P(t)}{N} dt \\
        &amp; = \frac{nb}{\delta t} \left(\frac{e^{r t^{\star}}}{rN} + \mathcal{O}(N^{-1})\right)\\
\end{align}
\]</span></p>
<p>Next we average our target cumulative incidence over the sample waiting time: <span class="math display">\[
\begin{align}
\hat{c} &amp; = \int_{t^{\star}}^{t^{\star} + \delta t} c(\hat{t} + t_d) \frac{d \hat{t}}{\delta t} \\
        &amp; = \int_{t^{\star}}^{t^{\star} + \delta t}
                \frac{r + \beta}{r} \frac{e^{r(\hat{t} + t_d)}}{N} \frac{d \hat{t}}{\delta t}
                + \mathcal{O}(N^{-1}) \\
        &amp; = (r + \beta)
            \left(\frac{e^{r t^{\star}}}{r N} \right)
            \left(\frac{e^{r \delta t} - 1}{r \delta t}\right)
            e^{r t_d}
            + \mathcal{O}(N^{-1}) \\
\end{align}
\]</span></p>
<p>This result has three components:</p>
<ol type="1">
<li>The first two terms are the cumulative incidence at <span class="math inline">\(t^{\star}\)</span>, the earliest possible detection time.</li>
<li>The third term in parentheses is the cost incurred from having widely spaced samples. As <span class="math inline">\(r \delta t \to 0\)</span>, this cost goes to zero. When <span class="math inline">\(r \delta t\)</span> is large, this cost grows exponentially.</li>
<li>The final term is the multiplier from the delay between sample collection and analysis.</li>
</ol>
<p>Finally, we notice that the second term in parentheses appears in our implicit equation for <span class="math inline">\(t^{\star}\)</span> above. Substituting and rearranging gives the sequencing effort (reads per unit time, <span class="math inline">\(n / \delta t\)</span>) required to detect by cumulative incidence <span class="math inline">\(\hat{c}\)</span>: <span class="math display">\[
\frac{n}{\delta t} = (r + \beta) \left(\frac{\hat{K}}{b \hat{c}} \right)
    \left(\frac{e^{r \delta t} - 1}{r \delta t}\right)
    e^{r t_d}
    + \mathcal{O}(N^{-1})
\]</span></p>
<p>Some observations:</p>
<ol type="1">
<li>Faster-growing and faster-recovering viruses require more sequencing because the current prevalence is a smaller fraction of the cumulative incidence.</li>
<li>Higher detection thresholds, lower P2RA factors (<span class="math inline">\(b\)</span>), and lower target cumulative incidence, require more sequencing.</li>
<li>There is a cost associated with longer sampling intervals and delays between collection and analysis. The latter grows faster than the former.</li>
</ol>
</section>
<section id="grab-sampling" class="level3">
<h3 class="anchored" data-anchor-id="grab-sampling">Grab sampling</h3>
<p>Now we turn to grab sampling at the collection times <span class="math inline">\(\{t_0, t_1, \ldots\}\)</span>. The analysis is the same as for continuous sampling, except that we will have a different implicit equation for <span class="math inline">\(t^{\star}\)</span>.</p>
<p>With grab sampling, <span class="math inline">\(\rho_i(t) = \delta(t - t_i)\)</span>, we have cumulative counts: <span class="math display">\[
\begin{align}
K_i &amp; = n \sum_{j=0}^{i} b \frac{P(t_i)}{N} \\
    &amp; = \frac{n b}{N} \sum_{j=0}^{i} e^{r (t_0 + j \delta t)} \\
    &amp; = \frac{n b}{N} e^{r t_0} \frac{e^{r(i+1)\delta t} - 1}{e^{r\delta t} - 1} \\
    &amp; = \frac{n b}{\delta t} \left(\frac{e^{r t_i}}{rN}\right)
        \left(\frac{r \delta t \, e^{r \delta t}}{e^{r \delta t} - 1}\right)
        + \mathcal{O}(N^{-1}). \\
\end{align}
\]</span> Making the continuous time substitution as before, gives <span class="math display">\[
\hat{K} = \frac{n b}{\delta t} \left(\frac{e^{r t^{\star}}}{rN}\right)
            \left(\frac{r \delta t \, e^{r \delta t}}{e^{r \delta t} - 1}\right)
            + \mathcal{O}(N^{-1}).
\]</span> The first two terms are identical to the continuous sampling case. The third term is the effect of grab sampling: because the sample is collected entirely at the end of the interval, the prevalence is higher than the average over the interval and you get more reads.</p>
<p>Using this equation for <span class="math inline">\(t^{\star}\)</span>, we find that the required sequencing effort for grab sampling is: <span class="math display">\[
\hat{c} = (r + \beta)
            \left(\frac{e^{r t^{\star}}}{r N} \right)
            \left(\frac{e^{r \delta t} - 1}{r \delta t}\right)
            e^{r t_d}
\]</span> <span class="math display">\[
\frac{n}{\delta t} = (r + \beta) \left(\frac{\hat{K}}{b \hat{c}} \right)
    \left(\frac
        {e^{-r\delta t} {\left(e^{r \delta t} - 1\right)}^2}
        {{\left(r \delta t\right)}^2}
        \right)
    e^{r t_d}
    + \mathcal{O}(N^{-1})
\]</span> This is similar to the continous sampling case but with weaker dependence on the sampling interval:</p>
<div id="ec356c30" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="ec356c30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="ec356c30-1"><a href="#ec356c30-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(<span class="fl">0.01</span>, <span class="dv">2</span>, <span class="fl">0.01</span>)</span>
<span id="ec356c30-2"><a href="#ec356c30-2" aria-hidden="true" tabindex="-1"></a>plt.plot(t, (np.exp(t) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> t, label<span class="op">=</span><span class="vs">r"Continuous sampling"</span>)</span>
<span id="ec356c30-3"><a href="#ec356c30-3" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.exp(<span class="op">-</span>t) <span class="op">*</span> ((np.exp(t) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> t) <span class="op">**</span> <span class="dv">2</span>, label<span class="op">=</span><span class="vs">r"Grab sampling"</span>)</span>
<span id="ec356c30-4"><a href="#ec356c30-4" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="ec356c30-5"><a href="#ec356c30-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Effect of wider sampling intervals"</span>)</span>
<span id="ec356c30-6"><a href="#ec356c30-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Sampling interval, $r \delta t$"</span>)</span>
<span id="ec356c30-7"><a href="#ec356c30-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Multiplicative effect on required sequencing depth"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:6: SyntaxWarning: invalid escape sequence '\d'
&lt;&gt;:6: SyntaxWarning: invalid escape sequence '\d'
/var/folders/dv/_dgh3jnn7kn32ndcd117mg5m0000gn/T/ipykernel_8448/798707106.py:6: SyntaxWarning: invalid escape sequence '\d'
  plt.xlabel("Sampling interval, $r \delta t$")</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-3-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We can also see the difference between the cases by comparing the Taylor series of the sampling interval delay term: <span class="math display">\[\begin{align}
f_{\text{cont.}}(r \delta t) &amp; \equiv \frac{e^{r \delta t} - 1}{r \delta t} = 1 + \frac{r \delta t}{2} + \frac{{(r \delta t)}^2}{6} \\
f_{\text{grab}}(r \delta t) &amp; \equiv \frac{e^{- r \delta t}{(e^{r \delta t} - 1)}^2}{r \delta t} = 1 + \frac{{(r \delta t)}^2}{12} \\
\end{align}\]</span></p>
</section>
</section>
<section id="numerical-example" class="level2">
<h2 class="anchored" data-anchor-id="numerical-example">Numerical example</h2>
<p>A function that calculates the depth required per unit time to detect by a given cumulative incidence:</p>
<div id="0be6b438" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="0be6b438"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="0be6b438-1"><a href="#0be6b438-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> depth_required(</span>
<span id="0be6b438-2"><a href="#0be6b438-2" aria-hidden="true" tabindex="-1"></a>    growth_rate: <span class="bu">float</span>,</span>
<span id="0be6b438-3"><a href="#0be6b438-3" aria-hidden="true" tabindex="-1"></a>    recovery_rate: <span class="bu">float</span>,</span>
<span id="0be6b438-4"><a href="#0be6b438-4" aria-hidden="true" tabindex="-1"></a>    read_threshold: <span class="bu">int</span>,</span>
<span id="0be6b438-5"><a href="#0be6b438-5" aria-hidden="true" tabindex="-1"></a>    p2ra_factor: <span class="bu">float</span>,</span>
<span id="0be6b438-6"><a href="#0be6b438-6" aria-hidden="true" tabindex="-1"></a>    cumulative_incidence_target: <span class="bu">float</span>,</span>
<span id="0be6b438-7"><a href="#0be6b438-7" aria-hidden="true" tabindex="-1"></a>    sampling_interval: <span class="bu">float</span>,</span>
<span id="0be6b438-8"><a href="#0be6b438-8" aria-hidden="true" tabindex="-1"></a>    sampling_scheme: <span class="bu">str</span>,</span>
<span id="0be6b438-9"><a href="#0be6b438-9" aria-hidden="true" tabindex="-1"></a>    delay: <span class="bu">float</span>,</span>
<span id="0be6b438-10"><a href="#0be6b438-10" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="0be6b438-11"><a href="#0be6b438-11" aria-hidden="true" tabindex="-1"></a>    leading_term <span class="op">=</span> (</span>
<span id="0be6b438-12"><a href="#0be6b438-12" aria-hidden="true" tabindex="-1"></a>        (growth_rate <span class="op">+</span> recovery_rate)</span>
<span id="0be6b438-13"><a href="#0be6b438-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span> read_threshold</span>
<span id="0be6b438-14"><a href="#0be6b438-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">/</span> (p2ra_factor <span class="op">*</span> cumulative_incidence_target)</span>
<span id="0be6b438-15"><a href="#0be6b438-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="0be6b438-16"><a href="#0be6b438-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> growth_rate <span class="op">*</span> sampling_interval</span>
<span id="0be6b438-17"><a href="#0be6b438-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sampling_scheme <span class="op">==</span> <span class="st">"continuous"</span>:</span>
<span id="0be6b438-18"><a href="#0be6b438-18" aria-hidden="true" tabindex="-1"></a>        sampling_term <span class="op">=</span> (np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x</span>
<span id="0be6b438-19"><a href="#0be6b438-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> sampling_scheme <span class="op">==</span> <span class="st">"grab"</span>:</span>
<span id="0be6b438-20"><a href="#0be6b438-20" aria-hidden="true" tabindex="-1"></a>        sampling_term <span class="op">=</span> np.exp(<span class="op">-</span>x) <span class="op">*</span> ((np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x) <span class="op">**</span> <span class="dv">2</span></span>
<span id="0be6b438-21"><a href="#0be6b438-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="0be6b438-22"><a href="#0be6b438-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"sampling_scheme must be continuous or grab"</span>)</span>
<span id="0be6b438-23"><a href="#0be6b438-23" aria-hidden="true" tabindex="-1"></a>    delay_term <span class="op">=</span> np.exp(growth_rate <span class="op">*</span> delay)</span>
<span id="0be6b438-24"><a href="#0be6b438-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> leading_term <span class="op">*</span> sampling_term <span class="op">*</span> delay_term</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ll measure time in days. Let’s assume:</p>
<ul>
<li>A virus with a doubling time of 1 week and recovery timescale of two weeks</li>
<li>A read threshold of 100 viral reads</li>
<li>An <span class="math inline">\(RA_i(1%)\)</span> of 1e-7 (approximate median SARS-CoV2 in Rothman)</li>
<li>A cumulative incidence target of 1%</li>
<li>A delay of one week for sample processing and sequencing</li>
<li>Vary the sampling scheme and sampling interval (from daily to monthly)</li>
</ul>
<div id="50670639" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="50670639"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="50670639-1"><a href="#50670639-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> np.log(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">7</span></span>
<span id="50670639-2"><a href="#50670639-2" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">14</span></span>
<span id="50670639-3"><a href="#50670639-3" aria-hidden="true" tabindex="-1"></a>k_hat <span class="op">=</span> <span class="dv">100</span></span>
<span id="50670639-4"><a href="#50670639-4" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> <span class="fl">1e-7</span></span>
<span id="50670639-5"><a href="#50670639-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="50670639-6"><a href="#50670639-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="50670639-7"><a href="#50670639-7" aria-hidden="true" tabindex="-1"></a>c_hat <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="50670639-8"><a href="#50670639-8" aria-hidden="true" tabindex="-1"></a>delta_t <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="dv">30</span>, <span class="dv">1</span>)</span>
<span id="50670639-9"><a href="#50670639-9" aria-hidden="true" tabindex="-1"></a>t_d <span class="op">=</span> <span class="fl">7.0</span></span>
<span id="50670639-10"><a href="#50670639-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="50670639-11"><a href="#50670639-11" aria-hidden="true" tabindex="-1"></a>n_cont <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"continuous"</span>, t_d)</span>
<span id="50670639-12"><a href="#50670639-12" aria-hidden="true" tabindex="-1"></a>n_grab <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"grab"</span>, t_d)</span>
<span id="50670639-13"><a href="#50670639-13" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, <span class="dv">30</span> <span class="op">*</span> n_cont, label<span class="op">=</span><span class="st">"continuous"</span>)</span>
<span id="50670639-14"><a href="#50670639-14" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, <span class="dv">30</span> <span class="op">*</span> n_grab, label<span class="op">=</span><span class="st">"grab"</span>)</span>
<span id="50670639-15"><a href="#50670639-15" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="fl">5.1e10</span>])</span>
<span id="50670639-16"><a href="#50670639-16" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">"Sampling scheme"</span>)</span>
<span id="50670639-17"><a href="#50670639-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Reads required per month"</span>)</span>
<span id="50670639-18"><a href="#50670639-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Sampling interval (days)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<ul>
<li>Vary the other parameters, make plots of interest?</li>
<li>Consider per-sample and per-read costs. Find the optimal sampling interval for each scheme.</li>
<li>Relax deterministic assumptions:
<ul>
<li>Poisson read count noise</li>
<li>“Excess” read count noise</li>
<li>Randomness in the spread of the virus</li>
</ul></li>
<li>Consider multiple sites
<ul>
<li>Accounting for global spread</li>
<li>Determining how to spread monitoring effort across locations</li>
</ul></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>